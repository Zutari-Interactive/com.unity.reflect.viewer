using System;
using System.Collections.Generic;
using Unity.Reflect;
using Unity.Reflect.Model;
using UnityEngine;
using UnityEngine.Reflect;
using UnityEngine.Reflect.Pipeline;

namespace $NAMESPACE
{
    [Serializable]
    public class $UNIVERSALNODENAME : ReflectNode<$NODEPROCESSORFILTERNAME>
    {
        public StreamInstanceInput InstanceInput   = new StreamInstanceInput();
        public GameObjectInput     GameObjectInput = new GameObjectInput();

        protected override $NODEPROCESSORFILTERNAME Create(ReflectBootstrapper hook, ISyncModelProvider provider,
                                                      IExposedPropertyTable resolver)
        {
            Debug.Log("Created new $NODEPROCESSORFILTERNAME.");
            $NODEPROCESSORFILTERNAME $NODEPROCESSORFILTERNAME = new $NODEPROCESSORFILTERNAME();

            InstanceInput.streamEvent = $NODEPROCESSORFILTERNAME.OnStreamInstanceEvent;
            GameObjectInput.streamEvent = $NODEPROCESSORFILTERNAME.OnGameObjectEvent;

            return $NODEPROCESSORFILTERNAME;
        }

        #region VARIABLES

        // THIS IS FOR YOUR VARIABLES

        #endregion

        #region CUSTOM METHODS

        // THIS IS WHERE YOU ADD YOUR CUSTOM FILTER METHODS

        #endregion
    }


    #region IREFLECT NODE PROCESSOR FILTER

    public class $NODEPROCESSORFILTERNAME : IReflectNodeProcessor
    {
        #region INTERNAL CLASS

        class FilterData
        {
            public bool                visible   = true;
            public HashSet<GameObject> instances = new HashSet<GameObject>();
        }

        #endregion

        #region VARIABLES

        private Dictionary<string, FilterData> _instances = new Dictionary<string, FilterData>();
        private ReflectClient                  _client;

        // ADD YOUR CUSTOM VARIABLES HERE
        // YOUR VARIABLES - START

        // YOUR VARIABLES - END

        #endregion

        #region PROPERTIES

        public IEnumerable<string> Categories
        {
            get { return _instances.Keys; }
        }

        #endregion

        #region CUSTOM METHODS

        // ADD YOUR CUSTOM METHODS HERE
        // YOUR METHODS - START

        public void Setup()
        {
            // CALL THIS METHOD IN A CUSTOM FILTER
        }

        public void SetupNode(CustomNode node)
        {
        }

        // YOUR METHODS - END

        #endregion

        #region NODE PROCESSOR METHODS

        public void OnStreamEvent(SyncedData<GameObject> gameObject, StreamEvent streamEvent)
        {
            Debug.Log($"STREAM EVEN FIRED - {gameObject.data.name}");
        }

        public void OnStreamInstanceEvent(SyncedData<StreamInstance> stream, StreamEvent streamEvent)
        {
            if (streamEvent != StreamEvent.Added)
                return;

            SyncMetadata metadata = stream.data.instance.Metadata;

            if (metadata != null && metadata.Parameters.TryGetValue("$CATEGORY", out SyncParameter category))
            {
                if (!_instances.ContainsKey(category.Value))
                {
                    _instances[category.Value] = new FilterData();
                }
            }
        }

        public void OnGameObjectEvent(SyncedData<GameObject> gameObjectData, StreamEvent streamEvent)
        {
            if (streamEvent == StreamEvent.Added)
            {
                OnGameObjectAdded(gameObjectData.data);
            }
            else if (streamEvent == StreamEvent.Removed)
            {
                OnGameObjectRemoved(gameObjectData.data);
            }
        }

        private void OnGameObjectAdded(GameObject gameObject)
        {
            if (!gameObject.TryGetComponent(out Metadata metadata))
                return;

            if (metadata.parameters.dictionary.TryGetValue("$CATEGORY", out Metadata.Parameter category))
            {
                if (!_instances.TryGetValue(category.value, out FilterData filter))
                    return;

                filter.instances.Add(gameObject);

                // YOUR CUSTOM CODE GOES HERE, THIS IS A UNIVERSAL CASE
                // THIS WILL BE APPLIED TO ALL OBJECTS IMPORTED THROUGH THE PIPELINE

                // YOUR CODE - START

                // YOUR CODE - END

                if (!filter.visible)
                {
                    gameObject.SetActive(false);
                }
            }
        }

        private void OnGameObjectRemoved(GameObject gameObject)
        {
            if (!gameObject.TryGetComponent(out Metadata metadata))
                return;

            if (metadata.parameters.dictionary.TryGetValue("$CATEGORY", out Metadata.Parameter category))
            {
                if (_instances.TryGetValue(category.value, out FilterData filter))
                {
                    filter.instances.Remove(gameObject);
                }
            }
        }

        public bool IsVisible(string category)
        {
            if (!_instances.TryGetValue(category, out FilterData filter))
                return true;

            return filter.visible;
        }

        public void SetVisibility(string category, bool visible)
        {
            if (!_instances.TryGetValue(category, out FilterData filter))
                return;

            if (filter.visible == visible)
                return;

            filter.visible = visible;

            foreach (GameObject instance in filter.instances)
            {
                instance.SetActive(visible);
            }
        }

        public void OnPipelineInitialized()
        {
            // OnPipelineInitialized is called the first time the pipeline is run.
        }

        public void OnPipelineShutdown()
        {
            // OnPipelineShutdown is called before the pipeline graph is destroyed.
        }

        #endregion
    }

    #endregion
}
